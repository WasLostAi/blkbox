// AI strategy types
export type TimeFrame = "1m" | "5m" | "15m" | "1h" | "4h" | "1d"
export type Market = "SOL-USDC" | "BTC-USDC" | "ETH-USDC" | "BLKBOX-USDC"
export type RiskLevel = "conservative" | "moderate" | "aggressive"

// Strategy interface
export interface Strategy {
  id: string
  name: string
  description: string
  market: Market
  timeframe: TimeFrame
  riskLevel: RiskLevel
  parameters: Record<string, any>
  code: string
  createdAt: number
  backtestResults?: BacktestResults
  userId?: string
}

// Backtest results interface
export interface BacktestResults {
  totalTrades: number
  winRate: number
  profitFactor: number
  sharpeRatio: number
  maxDrawdown: number
  annualizedReturn: number
  monthlyReturns: number[]
  equityCurve: { date: string; equity: number }[]
}

// Mock strategies
const strategies: Strategy[] = []

// Generate a strategy based on parameters
export async function generateStrategy(
  prompt: string,
  market: Market,
  timeframe: TimeFrame,
  riskLevel: number,
): Promise<Strategy> {
  // In a real implementation, you would call an AI model
  // For this demo, we'll return a mock strategy

  const riskLevelName: RiskLevel = riskLevel < 30 ? "conservative" : riskLevel < 70 ? "moderate" : "aggressive"

  const strategy: Strategy = {
    id: `strategy-${Date.now()}`,
    name: `${market} ${timeframe} Strategy`,
    description: prompt || `A ${riskLevelName} strategy for ${market} on the ${timeframe} timeframe`,
    market,
    timeframe,
    riskLevel: riskLevelName,
    parameters: {
      emaLength: 20,
      rsiLength: 14,
      atrLength: 14,
      positionSize: riskLevel / 10,
      maxDrawdown: riskLevel / 2,
      maxPositions: Math.max(1, Math.floor(riskLevel / 20)),
      trailingStop: 2.5,
      takeProfit: 3.75,
    },
    code: generateStrategyCode(market, timeframe, riskLevel),
    createdAt: Date.now(),
  }

  // Generate backtest results
  strategy.backtestResults = await backtestStrategy(strategy)

  // Add to strategies
  strategies.push(strategy)

  return strategy
}

// Generate strategy code
function generateStrategyCode(market: Market, timeframe: TimeFrame, riskLevel: number): string {
  return `// ${market} ${timeframe} Trading Strategy
// Risk Level: ${riskLevel}%
// Generated by $BLKBOX AI Strategy Lab

import { createStrategy } from '@blkbox/trading-core';
import { EMA, RSI, ATR, SMA } from '@blkbox/indicators';

export const strategy = createStrategy({
  id: 'momentum_volatility_filter',
  name: 'Momentum Strategy with Volatility Filter',
  description: 'A momentum-based approach with volatility filters',
  timeframe: '${timeframe}',
  
  // Initialize indicators
  init: (context) => {
    context.ema20 = EMA(20);
    context.rsi14 = RSI(14);
    context.atr14 = ATR(14);
    context.volSMA20 = SMA(20);
    
    // Risk parameters
    context.positionSize = ${riskLevel / 10}; // % of capital
    context.maxDrawdown = ${riskLevel / 2}; // %
    context.maxPositions = ${Math.max(1, Math.floor(riskLevel / 20))};
    context.trailingStop = 2.5; // %
    context.takeProfit = 3.75; // % (1.5:1 reward-to-risk)
  },
  
  // Entry logic
  onCandle: (candle, context) => {
    // Update indicators
    const ema = context.ema20.update(candle.close);
    const rsi = context.rsi14.update(candle.close);
    const atr = context.atr14.update(candle.high, candle.low, candle.close);
    const volSMA = context.volSMA20.update(candle.volume);
    
    // Store previous values
    const prevEma = context.ema20.result[context.ema20.result.length - 2];
    
    // Check for entry conditions
    const priceAboveEma = candle.close > ema;
    const prevPriceBelowEma = context.prevClose < prevEma;
    const emaCrossover = prevPriceBelowEma && priceAboveEma;
    const rsiFilter = rsi > 50 && rsi < 70;
    const volumeFilter = candle.volume > volSMA;
    
    // Check for exit conditions
    const priceBelowEma = candle.close < ema;
    const prevPriceAboveEma = context.prevClose > prevEma;
    const emaCrossUnder = prevPriceAboveEma && priceBelowEma;
    const rsiExit = rsi < 45;
    
    // Store current close for next candle
    context.prevClose = candle.close;
    
    // Entry logic
    if (!context.position && emaCrossover && rsiFilter && volumeFilter) {
      return {
        type: 'entry',
        direction: 'long',
        size: context.positionSize,
        stopLoss: candle.close * (1 - context.trailingStop / 100),
        takeProfit: candle.close * (1 + context.takeProfit / 100)
      };
    }
    
    // Exit logic
    if (context.position && (emaCrossUnder || rsiExit)) {
      return {
        type: 'exit',
        reason: emaCrossUnder ? 'ema_cross_under' : 'rsi_exit'
      };
    }
    
    // Update trailing stop if in position
    if (context.position) {
      const newStopPrice = candle.close * (1 - context.trailingStop / 100);
      if (newStopPrice > context.position.stopLoss) {
        return {
          type: 'update_stop',
          stopLoss: newStopPrice
        };
      }
    }
  }
});`
}

// Backtest a strategy
export async function backtestStrategy(strategy: Strategy): Promise<BacktestResults> {
  // In a real implementation, you would run a backtest
  // For this demo, we'll return mock results

  const riskLevel = strategy.riskLevel === "conservative" ? 20 : strategy.riskLevel === "moderate" ? 50 : 80

  // Generate random results based on risk level
  const winRate = 40 + Math.random() * 30 + riskLevel / 10
  const profitFactor = 1 + Math.random() + riskLevel / 100
  const sharpeRatio = 0.8 + Math.random() * 0.8 + riskLevel / 100
  const maxDrawdown = 5 + Math.random() * 10 + riskLevel / 10
  const annualizedReturn = 10 + Math.random() * 20 + riskLevel / 2

  // Generate monthly returns
  const monthlyReturns: number[] = []
  for (let i = 0; i < 12; i++) {
    const baseReturn = (annualizedReturn / 12) * (0.5 + Math.random())
    const isNegative = Math.random() < 0.3
    monthlyReturns.push(isNegative ? -baseReturn / 2 : baseReturn)
  }

  // Generate equity curve
  const equityCurve: { date: string; equity: number }[] = []
  const now = new Date()
  let equity = 10000 // Starting with $10,000

  for (let i = 180; i >= 0; i--) {
    const date = new Date(now)
    date.setDate(date.getDate() - i)

    // Daily return based on annualized return with some randomness
    const dailyReturn = (annualizedReturn / 365) * (0.5 + Math.random() * 1.5)
    const isNegative = Math.random() < 0.4
    const dailyChange = isNegative ? -dailyReturn / 2 : dailyReturn

    equity = equity * (1 + dailyChange / 100)

    equityCurve.push({
      date: date.toISOString().split("T")[0],
      equity,
    })
  }

  return {
    totalTrades: Math.floor(20 + Math.random() * 50),
    winRate,
    profitFactor,
    sharpeRatio,
    maxDrawdown,
    annualizedReturn,
    monthlyReturns,
    equityCurve,
  }
}

// Deploy a strategy
export async function deployStrategy(strategy: Strategy): Promise<boolean> {
  // In a real implementation, you would deploy the strategy to a trading engine
  // For this demo, we'll simulate deployment

  console.log(`Deploying strategy ${strategy.name} for ${strategy.market} on ${strategy.timeframe} timeframe`)

  // Simulate success
  return true
}

// Get strategy performance
export function getStrategyPerformance(strategyId: string): any {
  // In a real implementation, you would fetch actual performance
  // For this demo, we'll return mock data

  return {
    totalProfit: Math.random() * 1000 + 100,
    currentDrawdown: Math.random() * 5,
    openPositions: Math.floor(Math.random() * 3),
    lastTradeResult: Math.random() > 0.5 ? "win" : "loss",
    lastTradeProfit: Math.random() * 10 - 5,
  }
}

// Get all strategies
export function getAllStrategies(): Strategy[] {
  return strategies
}

// Get a strategy by ID
export function getStrategy(id: string): Strategy | undefined {
  return strategies.find((strategy) => strategy.id === id)
}
